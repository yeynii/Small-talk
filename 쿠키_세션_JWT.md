## 쿠키(HTTP 쿠키)

<aside>
🍪 인터넷 사용자가 어떠한 웹사이트를 방문할 경우 그 사이트가 사용하고 있는 서버를 통해 인터넷 사용자의 컴퓨터에 설치되는 작은 기록 정보 파일

</aside>

왜 쿠키인가?

- 헨젤과 그레텔 동화에서 자신이 지나온 길을 표시하게 위해 쿠키조각을 바닥에 떨어뜨리는것 = 서버에 요청한 사람이 누구인지 표시하기 위해 클라이언트에 쿠키를 남기는것
- 유닉스 운영체제에서 두 프로그램 사이에 전송되는 작은 데이터 패킷을 매직 쿠키라 불렀는데, 이를 웹에서 차용해서 사용하기 시작한 것

특징

- 클라이언트에 저장된다
- 한개에 4KB까지 저장 가능하다
- 이름, 값, 만료날짜, 경로 정보가 들어있다
- 기본적으로 웹브라우저가 종료되면 삭제되고(세션쿠키), 만료날짜를 지정해주면 만료일이 돼야 삭제된다(지속쿠키)
- 웹 브라우저에 해당 서버의 쿠키정보가 있으면 HTTP 요청에 무조건 담아 보낸다
- 특정 도메인에서 생성된 쿠키는 해당 도메인에서만 사용가능하다

## 세션(HTTP 세션)

<aside>
🎷 통신을 하기 위해 서로 연결된 순간부터 통신을 마칠 때 까지의 기간

클라이언트와 웹 서버간에 통신 연결에서 두 개체의 활성화된 접속

서버에 세션정보를 저장해 놓고 세션쿠키를 클라이언트에게 주어 서버가 클라이언트를 식별할 수 있도록하는 방식

서버에 클라이언트의 상태 정보를 저장하는 기술

</aside>

왜 세션인가?

- session : 시간, 시즌

특징

- 따로 용량의 제한이 없다.
- 서버에 세션 객체를 생성하며 각 클라이언트마다 고유한 세션 ID값을 부여한다.
- 쿠키를 사용하여 세션 ID값을 클라이언트에 보낸다.
- 웹 브라우저가 종료되면 세션 쿠키는 삭제된다.

> JWT 형식
Encoded Header + "." + Encoded Payload + "." + Verify Signature
> 

![스크린샷 2022-01-21 오전 10.38.38.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2230debd-af83-4f53-b7d7-76246f1b39b7/스크린샷_2022-01-21_오전_10.38.38.png)

## 인증방식

### 쿠키 / 세션 방식

[https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F994BEA345B53368401](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F994BEA345B53368401)

순서

1. 사용자가 로그인을 한다
2. 서버에서는 계정정보를 읽어 사용자를 확인한 후, 사용자의 고유한 ID값을 부여하여 세션 저장소에 저장한 후 이와 연결되는 세션ID(쿠키) 를 발행한다.
3. 사용자는 서버에서 해당 세션ID를 받아 쿠키에 저장을 한 후, 인증이 필요한 요청마다 쿠키를 헤더에 실어 보낸다.
4. 서버에서는 쿠키를 받아 세션 저장소에서 대조를 한 후 대응되는 정보를 가져온다
5. 인증이 완료되고 서버는 사용자에 맞는 데이터를 보내준다.

- 장점
    1. 쿠키는 세션 저장소에 담긴 정보를 가져오기 위한 열쇠역할일 뿐, 유의미한 값을 가지고 있지는 않음 (중요 정보는 서버 세션 저장소에)
    2. 사용자마다 고유 ID 값을 발급받으므로 서버측에서 쿠키값을 받았을 때 일일이 모든 회원정보를 확인할 필요 없이 바로 회원정보에 접근 할 수 있음

- 단점
    1. 특정 사용자의 HTTP요청을 해커가 가로채서 그 안의 쿠키를 훔칠 수 있음. 그 훔친 쿠키를 이용해 HTTP 요청을 보내면 세션 저장소에서 정보를 잘못 뿌려주게 됨 (세션 하이재킹 공격)
    2. 서버에서 세션 저장소를 사용하므로 추가적인 저장공간이 필요하고 부하도 높아짐 (Stateful)
    
    [해결책]
    
    - 쿠키/세션 → HTTPS를 사용해 요청 자체를 탈취해도 안의 정보를 읽기 힘들게 한다.
    - 세션에 유효시간을 넣어준다.

### JWT (토큰 기반 인증 방식)

<aside>
🪙 Json Web Token의 약자. 인증에 필요한 정보들을 암호화 시킨 토큰

</aside>

[https://t1.daumcdn.net/cfile/tistory/995EC2345B53368912](https://t1.daumcdn.net/cfile/tistory/995EC2345B53368912)

순서

1. 사용자가 로그인을 한다.

2. 서버에서는 계정정보를 읽어 사용자를 확인 후, 사용자의 고유한 ID값을 부여한 후, 기타 정보와 함께 Payload에 넣습니다.

3. JWT 토큰의 유효기간을 설정합니다.

4. 암호화할 SECRET KEY를 이용해 ACCESS TOKEN을 발급합니다.

5. 사용자는 Access Token을 받아 저장한 후, 인증이 필요한 요청마다 토큰을 헤더에 실어 보냅니다.

6. 서버에서는 해당 토큰의 Verify Signature를 SECRET KEY로 복호화한 후, 조작 여부, 유효기간을 확인합니다.

7. 검증이 완료된다면, Payload를 디코딩하여 사용자의 ID에 맞는 데이터를 가져옵니다.

- (Refresh Token)
    
    8. 시간이 지나 Access Token이 만료됐다고 보겠습니다.
    
    9. 사용자는 이전과 동일하게 Access Token을 헤더에 실어 요청을 보냅니다.
    
    10~11. 서버는 Access Token이 만료됨을 확인하고 권한없음을 신호로 보냅니다.
    
    - * Access Token 만료가 될 때마다 계속 과정 9~11을 거칠 필요는 없습니다.
    
    사용자(프론트엔드)에서 Access Token의 Payload를 통해 유효기간을 알 수 있습니다. 따라서 프론트엔드 단에서 API 요청 전에 토큰이 만료됐다면 바로 재발급 요청을 할 수도 있습니다.
    
    12. 사용자는 Refresh Token과 Access Token을 함께 서버로 보냅니다.
    
    **13. 서버는 받은 Access Token이 조작되지 않았는지 확인한후, Refresh Token과 사용자의 DB에 저장되어 있던 Refresh Token을 비교합니다. Token이 동일하고 유효기간도 지나지 않았다면 새로운 Access Token을 발급해줍니다.**
    
    14. 서버는 새로운 Access Token을 헤더에 실어 다시 API 요청을 진행합니다.
    

- 장점
    1. 별도의 저장소 관리가 필요없다 (Stateless)
    2. 확장성이 뛰어나고 유지, 보수하는데 유리함
    3. 토큰 기반으로 하는 다른 인증 시스템에 접근이 가능 함. (ex. 페이스북 로그인, 구글 로그인 등)

- 단점
    1. 이미 발급된 jwt에 대해서 돌이킬 수 없음. 세션/쿠키방식은 악의적인 접근이 예상되는 ID의 해당세션을 지워버리면 인증이 만료되지만 jwt방식은 불가능
    2. payload 정보가 제한적. payload는 암호화 되지 않기 때문에 중요 정보는 넣을 수 없음
    3. JWT의 길이는 세션/쿠키에 비해 길다. 요청이 많아질수록 서버의 자원낭비가 발생
    
    [해결책]
    
    - Access Token(유효기간 짧음)과 Refresh Token(유효기간 긺)을 함께 발급
        
        → Refresh Token의 저장소에 대한 고민... 주로 Access Token은 local storage에 Refresh Token은 서버사이드에 저장 (-> 좀 더 알아볼 것)
        
        → 프론트, 서버 모두 구현이 복잡해짐
        
        → Access Token이 만료 될 때마다 새롭게 발급하는 과정에서 생기는 HTTP 요청 횟수가 많아 서버의 자원낭비가 발생 - 프론트단에서 Access Token payload를 통해 유효기간을 알아내어 과정을 단축할 수 있음
